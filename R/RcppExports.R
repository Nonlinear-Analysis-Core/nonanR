# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximate Entropy
#' 
#' Calculate the approximate entropy of a time series.
#' 
#' @param x is the time series to analyse
#' @param dim is the embedding dimension of the time series
#' @param R is the radius in which to search for matches
#' @import Rcpp
#' @useDynLib nonanR
#' @export
#' 
#' @details Here are some additional details about approximate entropy.
#' 
#' @examples
#' 
#' x = rnorm(1000)
#' dim = 8
#' R = 0.2
#' 
#' AE = ApproximateEntropy(x, dim, R)
ApproximateEntropy <- function(x, dim, R) {
    .Call('_nonanR_ApproximateEntropy', PACKAGE = 'nonanR', x, dim, R)
}

#' Sample Entropy
#' 
#' Calculate the sample entropy of a time series.
#' 
#' @param x A single column time series
#' @param m The length of the vectors to be compared for matches
#' @param R The radius for accepting matches
#' @import Rcpp
#' @export
#'
#' @details Sample entropy can be used to quantify the complexity of a time series. A higher sample entropy value is associated with a more complex signal (more random). On the other hand a time series with a lower sample entropy value could be considered more predictable and repetitive.
#' 
#' @examples 
#' 
#' x = rnorm(1000)
#' m = 2
#' R = 0.2
#' 
#' SE = SampleEntropy(x, m, R)
#' 
#' @references
#' Richman, J.S., Moorman, J.R., 2000. Physiological time-series analysis using approximate entropy and sample entropy. Am. J. Physiol. Heart Circ. Physiol. 278. https://doi.org/10.1152/ajpheart.2000.278.6.H2039
SampleEntropy <- function(x, m, R) {
    .Call('_nonanR_SampleEntropy', PACKAGE = 'nonanR', x, m, R)
}

#' Symbolic Entropy 
#' 
#' Calculate the symbolic entropy of a time series.
#' 
#' @param x A vector of integers
#' @param thresholdVal The threshold of the search that you want to do
#' @param seqLength The length of the sequence that you want to find 
#' @import Rcpp
#' @export
#' 
#' @details Like all entropy functions, this one also quantifies the amount of complexity (or uncertainty/unpredictability) in the signal. Symbolic entropy can be used to gather greater insight into the underlying patterns seen in movement data.
#' 
#' @examples 
#' 
#' x = rnorm(1000)
#' thresholdVal = 2
#' seqLength = 0.2
#' 
#' SymE = SymbolicEntropy(x, thresholdVal, seqLength)
#' 
#' @references
#' Aziz, W., Arif, M. Complexity analysis of stride interval time series by threshold dependent symbolic entropy. Eur J Appl Physiol 98, 30â€“40 (2006). https://doi.org/10.1007/s00421-006-0226-5
SymbolicEntropy <- function(x, thresholdVal, seqLength) {
    .Call('_nonanR_SymbolicEntropy', PACKAGE = 'nonanR', x, thresholdVal, seqLength)
}

#' Detrended Fluctuation Analysis
#' 
#' Something a little more can go here
#' 
#' @param x A real values vector (i.e., time series data) to be analyzed.
#' @param order An integer indicating the polynomial order used for detrending the local windows (e.g., 1 = linear, 2 = quadratic, etc.).
#' @param verbose A boolean that when = 1 indicates that the flucuation function inlcuding the log of all included scales as well as the log Rms should be returned as well as the alpha or when = 0 only the estimated scaling exponent alpha will be returned.
#' @param scales An integer valued vector indicating the scales one wishes to resolve in the analysis.
#' @param scale_ratio A scaling factor by which to create successive window sizes from 'sc_min' to 'sc_max.
#' @import Rcpp
#' @export
#' 
#' @details DFA is useful in the analysis of many things but also it has a lot of requirements that should be met before using it.
#' 
#' @examples
#' 
#' x = rnorm(1000)
#' order = 1
#' verbose = 1
#' scales = c(16,32,64,128,256,512)
#' scale_ratio = 2
#' 
#' dfa_out = dfa(x, order, verbose, scales, scale_ratio)
#' 
#' @references
#' - Eke, A., Herman, P., Kocsis, L., & Kozak, L. R. (2002). Fractal characterization of complexity in temporal physiological signals. Physiological measurement, 23(1), R1-R38.
#' 
#' - Gulich, D., & Zunino, L. (2014). A criterion for the determination of optimal scaling ranges in DFA and MF-DFA. Physica A: Statistical Mechanics and its Applications, 397, 17-30.
#' 
#' - Kantelhardt, J. W., Koscielny-Bunde, E., Rego, H. H., Havlin, S., & Bunde, A. (2001). Detecting long-range correlations with detrended fluctuation analysis. Physica A: Statistical Mechanics and its Applications, 295(3-4), 441-454.
#' 
#' - Kelty-Stephen, D. G., Stirling, L. A., & Lipsitz, L. A. (2016). Multifractal temporal correlations in circle-tracing behaviors are associated with the executive function of rule-switching assessed by the Trail Making Test. Psychological assessment, 28(2), 171-180.
#'  
#' - Peng C-K, Buldyrev SV, Havlin S, Simons M, Stanley HE, and Goldberger AL (1994), Mosaic organization of DNA nucleotides, Physical Review E, 49, 1685-1689. 
#' 
#' - Peng C-K, Havlin S, Stanley HE, and Goldberger AL (1995), Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time series, Chaos, 5, 82-87.
#' 
#' - Perakakis, P., Taylor, M., Martinez-Nieto, E., Revithi, I., & Vila, J. (2009). Breathing frequency bias in fractal analysis of heart rate variability. Biological psychology, 82(1), 82-88.
dfa <- function(x, order, verbose, scales, scale_ratio = 2) {
    .Call('_nonanR_dfa', PACKAGE = 'nonanR', x, order, verbose, scales, scale_ratio)
}

#' Fractional Gaussian Noise Simulation
#' 
#' Function to generate Fractional Gaussian Noise
#' 
#' Create a time series with a specified Hurst value. 
#' 
#' @param n The length of the resulting time series
#' @param H The Hurst value of the resulting time series
#' @import Rcpp
#' @export
#' 
#' @examples 
#' 
#' ts_out = fgn_sim(n = 1000, H = 0.7)
fgn_sim <- function(n = 1000L, H = 0.7) {
    .Call('_nonanR_fgn_sim', PACKAGE = 'nonanR', n, H)
}

poly_residuals <- function(yr, m) {
    .Call('_nonanR_poly_residuals', PACKAGE = 'nonanR', yr, m)
}

lm_c <- function(xs, yr) {
    .Call('_nonanR_lm_c', PACKAGE = 'nonanR', xs, yr)
}

seq_int <- function(length) {
    .Call('_nonanR_seq_int', PACKAGE = 'nonanR', length)
}

#' Recurrence Quantification Analysis
#' 
#' This function performs recurrence quantification analysis.
#' 
#' @param ts1 A numerical time series
#' @param ts2 A numerical time series
#' @param embed The embedding dimension of the time series
#' @param delay The optimal time delay (lag)
#' @param normalize Should the time series be normalized? (0 = no, 1 = unit interval, 2 = z-score)
#' @param rescale Should the distance matrix be rescaled? (0 = no, 1 = max norm, 2 = min norm)
#' @param mindiagline The smallest number of diagonal points to be considered a line
#' @param minvertline smallest number of vertical points to be considered a line
#' @param t_win Theiler window
#' @param radius Minimum distance within which points are considered recurrent
#' @param whiteline not implemented
#' @param recpt Should recurrence plot be returned? (Not recommended for long series)
#' @import Rcpp
#' @export
#' 
#' @details This function performs recurrence quantification analysis (RQA) and its bivariate extension, cross recurrence quantification analysis (CRQA) on time series data that have (potentially) been embedded in higher dimension than the originating series. A common approach for univariate series involves several steps: First, identify the optimal time delay as either the first zero crossing of the autocorrelation function or the first minimum of the average mutual information function. Second, the time series is unfolded into embed dimensions by creating time-delayed copies of the original series. One method for determining the number of dimensions is by the method of False Nearest Neighbors. Third, a distance matrix is computed among the embedded points of the series. A recurrence plot is constructed by passing the distance matrix through a heavyside function: distances less than or equal to the chosen radius are marked as 1 (recurrent); distances falling outside the radius are marked as 0 (not recurrent).
#' 
#' After constructing the recurrence plot, a number of measures are computed to characterize recurrent structure in the time series. These measures and their interpretation are well documented in the literature. We provide simple definitions for each recurrence metric below. In addition, we provide references to standard readings including a very readable introduction to RQA (i.e., Webber & Zbilut, 2005; Marwan et al., 2007).
#' 
#' @examples
#' # Create a sample time series
#' x = fgn_sim(n = 100, H = 0.8)
#' 
#' # Compute RQA
#' x.recpt = rqa(x, x, 1, 1, 0, 1, 2, 2, 0, .0001, 0, 1)
#' 
#' # Return recurrence plot
#' plot_rqa(x.recpt$rp)
#' 
#' 
#' @references 
#' - Webber, C. L., & Zbilut, J. P. (2005). Recurrence quantification analysis of nonlinear dynamical time series. In S. Riley and G. C. Van Orden (eds). Tutorials in contemporary nonlinear methods for the behavioral sciences.
#' 
#' - Marwan, N., Romano, M. C. Theil, M., & Kurths, J. (2007). Recurrence plots for the analysis of complex systems. Physics Reports, 438, 237-329.
rqa <- function(ts1, ts2, embed = 1L, delay = 1L, normalize = 1L, rescale = 1L, mindiagline = 2L, minvertline = 2L, t_win = 0L, radius = 0.0001, whiteline = 0L, recpt = 0L) {
    .Call('_nonanR_rqa', PACKAGE = 'nonanR', ts1, ts2, embed, delay, normalize, rescale, mindiagline, minvertline, t_win, radius, whiteline, recpt)
}

