# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximate Entropy
#' 
#' Calculate the approximate entropy of a time series.
#' 
#' @param x is the time series to analyse
#' @param dim is the embedding dimension of the time series
#' @param R is the radius in which to search for matches
#' 
#' @returns The output of the algorithm is a single integer that reflects the entropy of the time series in bits.
#' 
#' @import Rcpp
#' @useDynLib nonanR
#' @export
#' 
#' @details Here are some additional details about approximate entropy.
#' 
#' @examples
#' 
#' x = rnorm(1000)
#' dim = 8
#' R = 0.2
#' 
#' AE = ApproximateEntropy(x, dim, R)
ApproximateEntropy <- function(x, dim, R) {
    .Call('_nonanR_ApproximateEntropy', PACKAGE = 'nonanR', x, dim, R)
}

ApproximateEntropyTest <- function(x, dim, R) {
    .Call('_nonanR_ApproximateEntropyTest', PACKAGE = 'nonanR', x, dim, R)
}

#' Sample Entropy
#' 
#' Calculate the sample entropy of a time series.
#' 
#' @param x A single column time series
#' @param m The length of the vectors to be compared for matches
#' @param R The radius for accepting matches
#' 
#' @returns The output of the algorithm is a single integer that reflects the entropy of the time series in bits.
#' 
#' @import Rcpp
#' @export
#'
#' @details Sample entropy can be used to quantify the complexity of a time series. A higher sample entropy value is associated with a more complex signal (more random). On the other hand a time series with a lower sample entropy value could be considered more predictable and repetitive.
#' 
#' @examples 
#' 
#' x = rnorm(1000)
#' m = 2
#' R = 0.2
#' 
#' SE = SampleEntropy(x, m, R)
#' 
#' @references
#' Richman, J.S., Moorman, J.R., 2000. Physiological time-series analysis using approximate entropy and sample entropy. Am. J. Physiol. Heart Circ. Physiol. 278. https://doi.org/10.1152/ajpheart.2000.278.6.H2039
SampleEntropy <- function(x, m, R) {
    .Call('_nonanR_SampleEntropy', PACKAGE = 'nonanR', x, m, R)
}

#' Symbolic Entropy 
#' 
#' Calculate the symbolic entropy of a time series.
#' 
#' @param x A vector of integers
#' @param thresholdVal The threshold of the search that you want to do
#' @param seqLength The length of the sequence that you want to find 
#' 
#' @returns The output of the algorithm is a single integer that reflects the entropy of the time series in bits.
#' 
#' @import Rcpp
#' @export
#' 
#' @details Like all entropy functions, this one also quantifies the amount of complexity (or uncertainty/unpredictability) in the signal. Symbolic entropy can be used to gather greater insight into the underlying patterns seen in movement data.
#' 
#' @examples 
#' 
#' x = rnorm(1000)
#' thresholdVal = 2
#' seqLength = 0.2
#' 
#' SymE = SymbolicEntropy(x, thresholdVal, seqLength)
#' 
#' @references
#' Aziz, W., Arif, M. Complexity analysis of stride interval time series by threshold dependent symbolic entropy. Eur J Appl Physiol 98, 30â€“40 (2006). https://doi.org/10.1007/s00421-006-0226-5
SymbolicEntropy <- function(x, thresholdVal, seqLength) {
    .Call('_nonanR_SymbolicEntropy', PACKAGE = 'nonanR', x, thresholdVal, seqLength)
}

#' Average Mutual Information
#'
#' Calculate the average mutual information of a time series.
#'
#' @param x - a single column time series
#' @param L - the maximum lag of the time series. This is usually the same as the sampling frequency.
#' @returns The output of the algorithm is a list that includes:
#' \itemize{
#'  \item \code{tau} A data frame of the local minima of the AMI values and the corresponding lag
#'  \item \code{ami} A data frame of all the AMI values at each lag
#' } 
#' @import Rcpp
#' @export
#'
#' @details AMI is part of the phase space reconstruction step that is needed for some nonlinear analysis methods.
#' 
#' 
#' @examples
#'
#' x = rnorm(1000)
#' L = 100
#'
#' ami_out = AMI(x, L)
#'
#'
ami <- function(x, y, L, bins) {
    .Call('_nonanR_ami', PACKAGE = 'nonanR', x, y, L, bins)
}

#' Detrended Fluctuation Analysis
#' 
#' Something a little more can go here
#' 
#' @param x A real values vector (i.e., time series data) to be analyzed.
#' @param order An integer indicating the polynomial order used for detrending the local windows (e.g., 1 = linear, 2 = quadratic, etc.).
#' @param verbose A boolean that when = 1 indicates that the flucuation function inlcuding the log of all included scales as well as the log Rms should be returned as well as the alpha or when = 0 only the estimated scaling exponent alpha will be returned.
#' @param scales An integer valued vector indicating the scales one wishes to resolve in the analysis.
#' @param scale_ratio A scaling factor by which to create successive window sizes from 'sc_min' to 'sc_max.
#' 
#' @returns The output of the algorithm is a list that includes:
#' \itemize{ 
#'  \item If the value of verbose = 1, then a list object is returned that includes: \code{log_scales}
#' the log of all included scales, \code{log_rms} the log root mean square error (RMS) per scale, and \code{alpha} the overall \eqn{\alpha} estimate.
#'  \item If the value of verbose = 0, then a list containing only `alpha` the estimated scaling exponent \eqn{\alpha} will be returned.
#' }
#' 
#' 
#' @import Rcpp
#' @export
#' 
#' @details DFA is useful in the analysis of many things but also it has a lot of requirements that should be met before using it.
#' 
#' @examples
#' 
#' x = rnorm(1000)
#' order = 1
#' verbose = 1
#' scales = c(16,32,64,128,256,512)
#' scale_ratio = 2
#' 
#' dfa_out = dfa(x, order, verbose, scales, scale_ratio)
#' 
#' @references
#' - Eke, A., Herman, P., Kocsis, L., & Kozak, L. R. (2002). Fractal characterization of complexity in temporal physiological signals. Physiological measurement, 23(1), R1-R38.
#' 
#' - Gulich, D., & Zunino, L. (2014). A criterion for the determination of optimal scaling ranges in DFA and MF-DFA. Physica A: Statistical Mechanics and its Applications, 397, 17-30.
#' 
#' - Kantelhardt, J. W., Koscielny-Bunde, E., Rego, H. H., Havlin, S., & Bunde, A. (2001). Detecting long-range correlations with detrended fluctuation analysis. Physica A: Statistical Mechanics and its Applications, 295(3-4), 441-454.
#' 
#' - Kelty-Stephen, D. G., Stirling, L. A., & Lipsitz, L. A. (2016). Multifractal temporal correlations in circle-tracing behaviors are associated with the executive function of rule-switching assessed by the Trail Making Test. Psychological assessment, 28(2), 171-180.
#'  
#' - Peng C-K, Buldyrev SV, Havlin S, Simons M, Stanley HE, and Goldberger AL (1994), Mosaic organization of DNA nucleotides, Physical Review E, 49, 1685-1689. 
#' 
#' - Peng C-K, Havlin S, Stanley HE, and Goldberger AL (1995), Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time series, Chaos, 5, 82-87.
#' 
#' - Perakakis, P., Taylor, M., Martinez-Nieto, E., Revithi, I., & Vila, J. (2009). Breathing frequency bias in fractal analysis of heart rate variability. Biological psychology, 82(1), 82-88.
dfa <- function(x, order, verbose, scales, scale_ratio = 2) {
    .Call('_nonanR_dfa', PACKAGE = 'nonanR', x, order, verbose, scales, scale_ratio)
}

#' Fractional Gaussian Noise Simulation
#' 
#' Function to generate Fractional Gaussian Noise
#' 
#' Create a time series with a specified Hurst value. 
#' 
#' @param n The length of the resulting time series
#' @param H The Hurst value of the resulting time series
#' 
#' @returns The output of the algorithm is a numeric vector of length \code{n}.  
#' 
#' @import Rcpp
#' @export
#' 
#' @examples 
#' 
#' ts_out = fgn_sim(n = 1000, H = 0.7)
fgn_sim <- function(n = 1000L, H = 0.7) {
    .Call('_nonanR_fgn_sim', PACKAGE = 'nonanR', n, H)
}

poly_residuals <- function(yr, m) {
    .Call('_nonanR_poly_residuals', PACKAGE = 'nonanR', yr, m)
}

lm_c <- function(xs, yr) {
    .Call('_nonanR_lm_c', PACKAGE = 'nonanR', xs, yr)
}

seq_int <- function(length) {
    .Call('_nonanR_seq_int', PACKAGE = 'nonanR', length)
}

#' Multifractal Detrended Fluctuation Analysis
#'
#' Fast function for computing multifractal detrended fluctuation analysis 
#' (MF-DFA), a widely used method for estimating the family of long-range 
#' temporal correlations or scaling exponents in time series data. 
#' MF-DFA is also a form of multifractal analysis that indicates the degree 
#' of interaction across temporal scales.
#' 
#' @param x A real valued vector (i.e., time series data) to be analyzed. 
#' @param q A real valued vector indicating the statistical moments (q) to use 
#' in the analysis. q must span negative and positive values (e.g., -3:3).
#' @param order is an integer indicating the polynomial order used for 
#' detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
#' is not pre-determined limit on the order of the polynomial order but the 
#' user should avoid using a large polynomial on small windows. This can result
#' in overfitting and non-meaningful estimates.
#' @param scales An integer valued vector indicating the scales one wishes to resolve
#' in the analysis. Best practice is to use scales which are evenly spaced in 
#' the logarithmic domain e.g., \code{scales = 2^(4:(N/4))}, where N is the length of the
#' time series. Other, logarithmic bases may also be used to give finer 
#' resolution of scales while maintaining ~= spacing in the log domain. Note that fractional bases may 
#' produce duplicate values after the necessary floor function.
#' @param scale_ratio A scaling factor by which successive window sizes 
#' are created. The default is 2 but should be addressed according to how 
#' scales were generated for example using \code{logscale(16, 100, 1.1)}, 
#' where 1.1 is the scale ratio.
#' @import Rcpp
#' @export
#' 
#' @details Details of the algorithm are specified in detail in Kantelhardt et al. (2001; 2002) and visualized nicely in Kelty-Stephen et al. (2016).
#' 
#' Selecting the range of values for q is important. Note that MF-DFA estimates for q = 2 are equivalent to DFA. Larger values of q (q > 2) emphasize larger residuals and smaller values of q
#' (q < 2) emphasis smaller residuals (Kelty-Stephen et al., 2016). For most biomedical signals such as physiological and kinematic, a q range of -5 to 5 is common (Ihlen, 2010). However, in some cases, 
#' such as when time series are short (< 3000), it can be appropriate to limit the range of q to positive only. Kelty-Stephen et al. (2016) recommend a 
#' positive q range of 0.5 to 10 with an increment of 0.5. 
#'
#' While it is common to use only linear detrending with DFA and MF-DFA, it is important to inspect the trends in the data to determine
#' if it would be more appropriate to use a higher order polynomial for detrending, and/or compare the DFA and MF-DFA output for different polynomial orders (see Ihlen, 2012; Kantelhardt et al., 2001).
#' 
#' General recommendations for choosing the min and max scale are a scale_min = 10 and scale_max = (N/4), where N is the number of observations.
#' See Eke et al. (2002), Gulich and Zunino (2014), Ihlen (2012), and  for additional considerations and information on choosing the correct parameters. 
#'
#' @returns The output of the algorithm is a list that includes:
#' \itemize{ 
#'  \item \code{log_scale} The log scales used for the analysis
#'  \item \code{log_fq} The log of the fluctuation functions for each scale and q 
#'  \item \code{Hq} The q-order Hurst exponent (generalized Hurst exponent)
#'  \item \code{Tau} The q-order mass exponent
#'  \item \code{q} The q-order statistical moments
#'  \item \code{h} The q-order singularity exponent
#'  \item \code{Dh} The dimension of the q-order singularity exponent
#'}
#'
#' @references 
#'
#' Ihlen, E. A. F. (2012). Introduction to Multifractal Detrended Fluctuation Analysis in Matlab. Frontiers in Physiology, 3. https://doi.org/10.3389/fphys.2012.00141
#'
#' Kantelhardt, J. W., Koscielny-Bunde, E., Rego, H. H., Havlin, S., & Bunde, A. (2001). Detecting long-range correlations with detrended fluctuation analysis. Physica A: Statistical Mechanics and its Applications, 295(3-4), 441-454.
#' 
#' Kantelhardt, J. W., Zschiegner, S. A., Koscielny-Bunde, E., Havlin, S., Bunde, A., & Stanley, H. E. (2002). Multifractal detrended fluctuation analysis of nonstationary time series. Physica A: Statistical Mechanics and its Applications, 316(1-4), 87-114.
#'
#' Kelty-Stephen, D. G., Palatinus, K., Saltzman, E., & Dixon, J. A. (2013). A Tutorial on Multifractality, Cascades, and Interactivity for Empirical Time Series in Ecological Science. Ecological Psychology, 25(1), 1-62. https://doi.org/10.1080/10407413.2013.753804
#'
#' Kelty-Stephen, D. G., Stirling, L. A., & Lipsitz, L. A. (2016). Multifractal temporal correlations in circle-tracing behaviors are associated with the executive function of rule-switching assessed by the Trail Making Test. Psychological Assessment, 28(2), 171-180. https://doi.org/10.1037/pas0000177
#'
#' @examples
#' 
#' # White Noise
#' white_noise_ts = fgn_sim(n = 1000, H = 0.5)
#' 
#' q = -5:5
#' order = 1
#' scales = c(16,32,64,128,256,512)
#' scale_ratio = 2
#'
#'
#' mf.dfa.white.out <- mfdfa(
#'     x = white_noise_ts, 
#'     q = q, 
#'     order = order, 
#'     scales = scales, 
#'     scale_ratio = scale_ratio) 
#'  
#' # Pink Noise
#' pink_noise_ts <- fgn_sim(n = 1000, H = 0.9)
#' 
#' mf.dfa.pink.out <- mfdfa(
#'     x = pink_noise_ts, 
#'     q = q, 
#'     order = order, 
#'     scales = scales, 
#'     scale_ratio = scale_ratio) 
#'
#' 
mfdfa <- function(x, q, order, scales, scale_ratio) {
    .Call('_nonanR_mfdfa', PACKAGE = 'nonanR', x, q, order, scales, scale_ratio)
}

#' Recurrence Quantification Analysis
#' 
#' This function performs recurrence quantification analysis.
#' 
#' @param ts1 A numerical time series
#' @param ts2 A numerical time series
#' @param embed The embedding dimension of the time series
#' @param delay The optimal time delay (lag)
#' @param normalize Should the time series be normalized? (0 = no, 1 = unit interval, 2 = z-score)
#' @param rescale Should the distance matrix be rescaled? (0 = no, 1 = max norm, 2 = min norm)
#' @param mindiagline The smallest number of diagonal points to be considered a line
#' @param minvertline smallest number of vertical points to be considered a line
#' @param t_win Theiler window
#' @param radius Minimum distance within which points are considered recurrent
#' @param whiteline not implemented
#' @param recpt Should recurrence plot be returned? (Not recommended for long series)
#' 
#' @returns The output of the algorithm is a list that includes:
#' \itemize{
#'  \item \code{rr}: (Recurrence rate), the overall percentage of recurrent points
#'  \item \code{det}: (determinism), the percentage of recurrent points that fall on a line
#'  \item \code{div}: (divergence), inverse of determinism i.e. 1/det
#'  \item \code{nrline}: (number of lines), total number of lines in the upper triangle
#'  \item \code{ratio}: (ratio), percent determinism/percent recurrence i.e det/rr
#'  \item \code{maxline}: (longest line), the number points in the longest diagonal line
#'  \item \code{meanline}: (average line), average length of diagonal lines
#'  \item \code{lam}: (laminarity), perecentage of points that fall on vertical lines
#'  \item \code{tt}: (trapping time), average length of vertical lines
#'  \item \code{vmax}: (longest vertical line), the number of points in the longest vertical line
#'  \item \code{entropy}: (Shannon entropy), based on distribution of line lengths
#'  \item \code{rentropy}: (relative entropy), Shannon entropy normalized by number of lines 
#' }
#' Optionally, you can return the recurrence matrix but caution should be taken when returning this especially with larger time series as it can take some time.
#' 
#' @import Rcpp
#' @export
#' 
#' @details This function performs recurrence quantification analysis (RQA) and its bivariate extension, cross recurrence quantification analysis (CRQA) on time series data that have (potentially) been embedded in higher dimension than the originating series. A common approach for univariate series involves several steps: First, identify the optimal time delay as either the first zero crossing of the autocorrelation function or the first minimum of the average mutual information function. Second, the time series is unfolded into embed dimensions by creating time-delayed copies of the original series. One method for determining the number of dimensions is by the method of False Nearest Neighbors. Third, a distance matrix is computed among the embedded points of the series. A recurrence plot is constructed by passing the distance matrix through a heavyside function: distances less than or equal to the chosen radius are marked as 1 (recurrent); distances falling outside the radius are marked as 0 (not recurrent).
#' 
#' After constructing the recurrence plot, a number of measures are computed to characterize recurrent structure in the time series. These measures and their interpretation are well documented in the literature. We provide simple definitions for each recurrence metric below. In addition, we provide references to standard readings including a very readable introduction to RQA (i.e., Webber & Zbilut, 2005; Marwan et al., 2007).
#' 
#' @examples
#' # Create a sample time series
#' x = fgn_sim(n = 100, H = 0.8)
#' 
#' # Compute RQA
#' x.recpt = rqa(x, x, 1, 1, 0, 1, 2, 2, 0, .0001, 0, 1)
#' 
#' # Return recurrence plot
#' plot_rqa(x.recpt$rp)
#' 
#' 
#' @references 
#' - Webber, C. L., & Zbilut, J. P. (2005). Recurrence quantification analysis of nonlinear dynamical time series. In S. Riley and G. C. Van Orden (eds). Tutorials in contemporary nonlinear methods for the behavioral sciences.
#' 
#' - Marwan, N., Romano, M. C. Theil, M., & Kurths, J. (2007). Recurrence plots for the analysis of complex systems. Physics Reports, 438, 237-329.
rqa <- function(ts1, ts2, embed = 1L, delay = 1L, normalize = 1L, rescale = 1L, mindiagline = 2L, minvertline = 2L, t_win = 0L, radius = 0.0001, whiteline = 0L, recpt = 0L) {
    .Call('_nonanR_rqa', PACKAGE = 'nonanR', ts1, ts2, embed, delay, normalize, rescale, mindiagline, minvertline, t_win, radius, whiteline, recpt)
}

